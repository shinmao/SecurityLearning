# Crypto
Title | Content
------------ | -------------
[tech words]() | some concepts
[attack type]() | known-attack, -only attack
Classical cipher | [Hill cipher]()  
[DES]() | encryption, property, vulnerability

# Tech words
Avalanche effect: even little part of input changes would cause to the big change in output. One ideal attribute of crypto algorithm.  

Confusion: makes the relationship between key and ciphertext more obscure. Substitution is one implementation of confusion. This is both used in DES and AES.  

Diffusion: in order to hide feature of frequency, make the impact of single character diffuse to the whole ciphertext. Transposition is one implementation of diffusion, and it is usually used in DES.

# Types of attack

## Ciphertext-only attack
Only know about ciphertext. Frequency analysis attack might be one way to attack

## Known-plaintext attack
Know several pairs of plaintext and ciphertext.

## Chosen-plaintext attack
Chose a plaintext and try to get the encrypted plaintext.

# Hill cipher
Hill cipher is one type of substitution cipher based on matrix operation. The most drawback of substitution is frequency analysis attack, hill cipher is born with feature of hidden character frequency. Hill cipher would separate plaintext to several groups and encrypt them with matrix operation.  
```
C = Ek(P) = KP
P = Dk(C) = (K^-1)KP
```

## Encryption  
K = key matrix  
Change the characters in plaintext into numbers  
The size of each groups would be the same as width/length of key matrix. (This is also because each groups need to multiply with key matrix)  
```
H I => 8 9
 _     _    _   _     _    _
|  2  5 |  |  8  |   |  56  |
|  4  7 |* |  9  | = |  95  |
| _   _ |  |_   _|   |_    _|
```
56 mod 26 = 4 => E  
95 mod 26 = 17 => R  
In the example above, plaintext is separated into groups of size 2. You can find that `H` in different groups would also encrypted into different character, so hill cipher uses this way to prevent frequent analysis attack. If the key length is less than 2*N, you would need to make a padding to fill it.

## Requirement of key matrix  
There is also a limitation of key matrix: your determine value of key matrix cannot be 0, which means your key matrix need to be inversible. Only by this way, encrypted text can be decrypted! Here you need to be familiar with the methods of getting inverse matrix.

## Vulnerable to known-plaintext attack
Try to imagine attackers know several pairs of plaintext and ciphertext.  
```
                         _    _
                        | a  b |
[ c1 c2 ] = [ p1 p2 ] * |      |
                        | c  d |
                         -    - 
```
If you have two pairs of plain/ciphertext, it would be enough for you to get (a, b, c, d).

# DES
* Data Encryption Standard. DES is not secure anymore because the size of his key is so small, and it is already replaced with AES todays. 
* DES uses key size of 56 bits to encrypt plaintext size of 64 bits.  
* DES is one kind of symmetric cipher. DES would use 16 rounds of same operations on each groups of plaintext. Each rounds would also use different subkeys, and all subkeys are deduced from the original k.
* Feistel network: the feistel structure of DES
```
// pesudo
64 bits of plaintext -> IP -> L0/R0 (32bits)
for i = 1; i <= 16; i++ {
    Li = Ri-1
    Ri = Li-1  XOR  f(Ri-1, ki) // ki of 48 bits
}
Ln+1 = Rn
Rn+1 = Ln
ciphertext = Ln+1Rn+1
```
what's interesting, `f()` only encrypts parts of input, the other part would be copied to the next round.  
1. **IP**:  

x | x | x | x | x | x | x | x 
------------ | ------------- | ------------ | ------------- | ------------ | ------------- | ------------ | -------------
58 | 50 | 42 | 34 | 26 | 18 | 10 | 2
60 | 52 | 44 | 36 | 28 | 20 | 12 | 4
62 | 54 | 46 | 38 | 30 | 22 | 14 | 6
64 | 56 | 48 | 40 | 32 | 24 | 16 | 8
57 | 49 | 41 | 33 | 25 | 17 | 9 | 1
59 | 51 | 43 | 35 | 27 | 19 | 11 | 3
61 | 53 | 45 | 37 | 29 | 21 | 13 | 5
63 | 55 | 47 | 39 | 31 | 23 | 15 | 7  
Above is the output of initial permutation.  

2. **Ki**:  
Ki in each rounds is generated by **key schedule**.  
PC1, permutated choice 1: from input of 64 bits to get two output of 28 bits.  

C0 | x | x | x | x | x | x 
------------ | ------------- | ------------ | ------------- | ------------ | ------------- | ------------ 
57 | 49 | 41 | 33 | 25 | 17 | 9
1 | 58 | 50 | 42 | 34 | 26 | 18
10 | 2 | 59 | 51 | 43 | 35 | 27
19 | 11 | 3 | 60 | 52 | 44 | 36
D0 | x | x | x | x | x | x
63 | 55 | 47 | 39 | 31 | 23 | 15
7 | 62 | 54 | 46 | 38 | 30 | 22
14 | 6 | 61 | 53 | 45 | 37 | 29
21 | 13 | 5 | 28 | 20 | 12 | 4
We can see that 8, 16, 24, 32, 40, 48, 56, 64 are not used because they are used for **parity bit**.  
circular left shift for different bits in each rounds  
i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 
------------ | ------------- | ------------ | ------------- | ------------ | ------------- | ------------ | ------------ | ------------- |  ------------ | ------------- | ------------ | ------------- | ------------ | ------------- | ------------ | -------------
ls | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 1
After left shift, concatenate C0 and D0 together, then we can get output of 56 bits.  

PC2, permutated choice 2: from input of 56 bits to get output of 48 bits.  

PC2 | x | x | x | x | x
------------ | ------------- | ------------ | ------------- | ------------ | ------------- 
14 | 17 | 11 | 24 | 1 | 5
3 | 28 | 15 | 6 | 21 | 10
23 | 19 | 12 | 4 | 26 | 8
16 | 7 | 27 | 20 | 13 | 2
41 | 52 | 31 | 37 | 47 | 55
30 | 40 | 51 | 45 | 33 | 48
44 | 49 | 39 | 56 | 34 | 53
46 | 42 | 50 | 36 | 29 | 32
And get ki

```
PC1 -> C0/D0
for i=1; i<=16; i++{
    Ci = ls(Ci-1)
    Di = ls(Di-1)
    ki = PC2(CiDi)
}
```
3. **Mangler function, f**:  
input: 32 bits of half block and 48 bits of subkey.  

Expansion: to make 32 bits expand to 48 bits because they need to do XOR.  
Ep | x | x | x | x | x
------------ | ------------- | ------------ | ------------- | ------------ | ------------- 
32 | 1 | 2 | 3 | 4 | 5
4 | 5 | 6 | 7 | 8 | 9
8 | 9 | 10 | 11 | 12 | 13
12 | 13 | 14 | 15 | 16 | 17
16 | 17 | 18 | 19 | 20 | 21
20 | 21 | 22 | 23 | 24 | 25
24 | 25 | 26 | 27 | 28 | 29
28 | 29 | 30 | 31 | 32 | 1
Then XOR with subkey. It would be separated to 8 groups, and each groups has 6 bits.

Substitution-Box (sbox): Each sboxs would change 6 bits to 4 bits. Each sboxs has different methods to calculate output, and concatenate them together to get the output of 32 bits. Finally, premutation again!  
sbox is also the core of DES, and also is the only element which is not linear in the algorithm.

The return value of function would be:  
```
P(Sbox1Sbox2â‹¯Sbox8)
```

4. Final permutation:
After 16 rounds of encryption with function, we can get L16 and R16. We exchange it again:  
```
fin-pm(R16L16)
```
FP | x | x | x | x | x | x | x 
------------ | ------------- | ------------ | ------------- | ------------ | ------------- | ------------ | -------------
40 | 8 | 48 | 16 | 56 | 24 | 64 | 32
39 | 7 | 47 | 15 | 55 | 23 | 63 | 31
38 | 6 | 46 | 14 | 54 | 22 | 62 | 30
37 | 5 | 45 | 13 | 53 | 21 | 61 | 29
36 | 4 | 44 | 12 | 52 | 20 | 60 | 28
35 | 3 | 43 | 11 | 51 | 19 | 59 | 27
34 | 2 | 42 | 10 | 50 | 18 | 58 | 26
33 | 1 | 41 | 9 | 49 | 17 | 57 | 25   

**3DES**:  
First, why no 2DES?  
assume 2DES exists  
encryption: P -> Ek1 -> middle value -> Ek2 -> C  
decryption: C -> Dk2 -> middle value -> Dk1 -> P  
If attackers have pair of P and C, then he can use  
```
Ek1(P) = M = Dk2(C)
```  
To leak k1 and k2 in O(2*2^56), and this is not different from DES so much! So 2DES should not be our solutions!  
Triple data encryption - 3DES is created, which uses three 56 bits key to encrypt.  
```
C = EK3( DK2( EK1( P ) ) )
```
keys has three options of features:  
* k1, k2, k3 are independent  
* k1 and k2 are independent, k3 = k1
* three keys are the same

EDE mode (encrypt-decrypt-encrypt) with two keys or three keys.  
But why not use encryption three times?  
The purpose is to preserve compatibility of DES. If you choose the same key for EEE, then it would be same as DES (because en->de->en). EEE is also a option, but not top option such as EDE.  

**vul to exhaustive key search attack**:  
input: pair of plaintext/ciphertext (x, y)  
output: k which fulfills y = DESk(x)  
attack: try all 2^56 possible keys until you find the key can help you decrypt to plaintext. 